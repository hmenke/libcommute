

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Virasoro algebra &mdash; libcommute 0.5 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Index" href="../genindex.html" />
    <link rel="prev" title="Custom scalar types and parametric_loperator" href="parametric_loperator.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> libcommute
          

          
            
            <img src="../_static/logo_small.svg" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.5
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage.html">How to use <em>libcommute</em> in your project</a></li>
<li class="toctree-l1"><a class="reference internal" href="../expression/index.html">Domain-Specific Language for polynomial expressions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../loperator/index.html">Tools for exact diagonalization</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Advanced examples</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="kanamori.html">Kanamori interaction Hamiltonian</a></li>
<li class="toctree-l2"><a class="reference internal" href="jaynes_cummings.html">Jaynes-Cummings ladder</a></li>
<li class="toctree-l2"><a class="reference internal" href="heisenberg_chain.html">Spin-1/2 Heisenberg chain and its integrals of motion</a></li>
<li class="toctree-l2"><a class="reference internal" href="parametric_loperator.html">Custom scalar types and <code class="docutils literal notranslate"><span class="pre">parametric_loperator</span></code></a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Virasoro algebra</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../genindex.html">Index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../search.html">Search</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">libcommute</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Advanced examples</a> &raquo;</li>
        
      <li>Virasoro algebra</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/examples/virasoro_algebra.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="virasoro-algebra">
<span id="id1"></span><h1>Virasoro algebra<a class="headerlink" href="#virasoro-algebra" title="Permalink to this headline">¶</a></h1>
<p>Virasoro algebra is the central extension of a Lie algebra with wide applications
in the two-dimensional conformal field theory. Its generators
<span class="math notranslate nohighlight">\(L_n, n \in \mathbb{Z}\)</span> satisfy commutation relations</p>
<div class="math notranslate nohighlight">
\[[L_m, L_n] = (m - n) L_{m+n} + c(m^3 - m) \delta_{m, -n},\]</div>
<p>where <span class="math notranslate nohighlight">\(c\)</span> is the central charge commuting with all generators. It was
shown in <a class="reference internal" href="#fnz88" id="id2"><span>[FNZ88]</span></a> that the Virasoro algebra can be constructed out of just
two generators <span class="math notranslate nohighlight">\(L_3\)</span> and <span class="math notranslate nohighlight">\(L_{-2}\)</span> using the following recurrence
relations,</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
  L_1 &amp;= \frac{1}{5}[L_3, L_{-2}],\\
  L_{-1} &amp;= \frac{1}{3}[L_1, L_{-2}],\\
  L_2 &amp;= \frac{1}{4}[L_3, L_{-1}],\\
  L_0 &amp;= \frac{1}{2}[L_1, L_{-1}],\\
  L_{n+1} &amp;= \frac{1}{n-1}[L_n, L_1] \text{ for } n&gt;2,\\
  L_{-n-1} &amp;= \frac{1}{1-n}[L_{-n}, L_{-1}] \text{ for } n&gt;1.
\end{align}\end{split}\]</div>
<p>In the example below, we show how to implement the Virasoro algebra in
<em>libcommute</em>’s framework and use it to verify the recurrence relations stated
above.</p>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;tuple&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;libcommute/libcommute.hpp&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">libcommute</span> <span class="p">{</span>

<span class="c1">// Define a new generator type by deriving from the abstract base class</span>
<span class="c1">// &#39;libcommute::generator&lt;IndexTypes...&gt;&#39;. Generators of the Virasoro algebra</span>
<span class="c1">// L_n carry one integer index &#39;n&#39;.</span>
<span class="c1">// Canonical order of generators in a monomial L_n * L_m * L_k * ... is such</span>
<span class="c1">// that n &lt; m &lt; k &lt; ...</span>
<span class="k">class</span> <span class="nc">generator_virasoro</span> <span class="o">:</span> <span class="k">public</span> <span class="n">generator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">{</span>

  <span class="k">using</span> <span class="n">base</span> <span class="o">=</span> <span class="n">generator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">using</span> <span class="n">linear_function_t</span> <span class="o">=</span> <span class="k">typename</span> <span class="nc">base</span><span class="o">::</span><span class="n">linear_function_t</span><span class="p">;</span>

  <span class="c1">// For the sake of simplicity, we fix the central charge once and for all.</span>
  <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">double</span> <span class="n">central_charge</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>

  <span class="c1">// This function must return a unique algebra ID shared by all generators</span>
  <span class="c1">// of a particular algebra.</span>
  <span class="k">virtual</span> <span class="kt">int</span> <span class="n">algebra_id</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
    <span class="c1">// Use the lowest algebra ID available to user-defined algebras</span>
    <span class="k">return</span> <span class="n">LIBCOMMUTE_MIN_USER_DEFINED_ALGEBRA_ID</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Construct generator with a given index &#39;n&#39;</span>
  <span class="n">generator_virasoro</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="o">:</span> <span class="n">base</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{}</span>
  <span class="c1">// Standard constructors, assignments and destructor</span>
  <span class="n">generator_virasoro</span><span class="p">(</span><span class="n">generator_virasoro</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="n">generator_virasoro</span><span class="p">(</span><span class="n">generator_virasoro</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="n">generator_virasoro</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">generator_virasoro</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="n">generator_virasoro</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">generator_virasoro</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">generator_virasoro</span><span class="p">()</span> <span class="p">{}</span>

  <span class="c1">// Virtual copy-constructor: Make a smart pointer managing</span>
  <span class="c1">// a copy of this generator</span>
  <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">base</span><span class="o">&gt;</span> <span class="n">clone</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">make_unique</span><span class="o">&lt;</span><span class="n">generator_virasoro</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// Given a product L_m * L_n with m &gt; n, transform it to the canonically</span>
  <span class="c1">// ordered form L_n * L_m plus some linear function of generators.</span>
  <span class="c1">// For the Virasoro algebra the transformation is</span>
  <span class="c1">//</span>
  <span class="c1">// L_m * L_n -&gt; L_n * L_m + (m-n)*L_{m+n} + c(m^3 - m)\delta(m,-n)</span>
  <span class="c1">//</span>
  <span class="c1">// L_m will be passed to swap_with() as *this, i.e. L_m.swap_with(L_n, f).</span>
  <span class="k">virtual</span> <span class="kt">double</span>
  <span class="n">swap_with</span><span class="p">(</span><span class="n">base</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">L_n</span><span class="p">,</span> <span class="n">linear_function_t</span> <span class="o">&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
    <span class="c1">// Ensure that L_m &gt; L_n, or equivalently m &gt; n.</span>
    <span class="n">assert</span><span class="p">(</span><span class="o">*</span><span class="k">this</span> <span class="o">&gt;</span> <span class="n">L_n</span><span class="p">);</span>

    <span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">L_n_</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">generator_virasoro</span> <span class="k">const</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">L_n</span><span class="p">);</span>

    <span class="c1">// Extract indices from L_m and L_n</span>
    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">base</span><span class="o">::</span><span class="n">indices_</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">L_n_</span><span class="p">.</span><span class="n">indices_</span><span class="p">);</span>

    <span class="c1">// Write linear terms of the transformed expressions into &#39;f&#39;</span>
    <span class="n">f</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="o">-</span><span class="n">n</span> <span class="o">?</span> <span class="p">(</span><span class="n">central_charge</span> <span class="o">*</span> <span class="p">(</span><span class="n">m</span><span class="o">*</span><span class="n">m</span><span class="o">*</span><span class="n">m</span> <span class="o">-</span> <span class="n">m</span><span class="p">))</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span> <span class="c1">// Constant term</span>
      <span class="n">make_unique</span><span class="o">&lt;</span><span class="n">generator_virasoro</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="n">n</span><span class="p">),</span> <span class="c1">// L_{m+n}</span>
      <span class="n">m</span> <span class="o">-</span> <span class="n">n</span>                                   <span class="c1">// Coefficient in front of L_{m+n}</span>
    <span class="p">);</span>

    <span class="c1">// Return coefficient in front of L_n * L_m in the transformed expression</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Given a product L_m * L_n with m &lt;= n, optionally transform it to</span>
  <span class="c1">// some linear function of generators. For the Virasoro algebra such a</span>
  <span class="c1">// transformation exists for L_m = L_n,</span>
  <span class="c1">//</span>
  <span class="c1">// L_m * L_n -&gt; 0</span>
  <span class="c1">//</span>
  <span class="c1">// L_m will be passed to simplify_prod() as *this,</span>
  <span class="c1">// i.e. L_m.simplify_prod(L_n, f).</span>
  <span class="k">virtual</span> <span class="kt">bool</span>
  <span class="n">simplify_prod</span><span class="p">(</span><span class="n">base</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">L_n</span><span class="p">,</span> <span class="n">linear_function_t</span> <span class="o">&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
    <span class="c1">// Ensure that L_m &lt;= L_n, or equivalently m &lt;= n.</span>
    <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="k">this</span> <span class="o">&gt;</span> <span class="n">L_n</span><span class="p">));</span>

    <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="k">this</span> <span class="o">==</span> <span class="n">L_n</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// The transformed product is identically zero</span>
      <span class="n">f</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// No suitable transformation can be applied</span>
  <span class="p">}</span>

  <span class="c1">// Hermitian conjugate: (L_n)^\dagger = L_{-n}</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">conj</span><span class="p">(</span><span class="n">linear_function_t</span> <span class="o">&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">conj_n</span> <span class="o">=</span> <span class="o">-</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">base</span><span class="o">::</span><span class="n">indices_</span><span class="p">);</span>
    <span class="n">f</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">make_unique</span><span class="o">&lt;</span><span class="n">generator_virasoro</span><span class="o">&gt;</span><span class="p">(</span><span class="n">conj_n</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// Print L_n to stream</span>
  <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span> <span class="n">print</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span> <span class="n">os</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">base</span><span class="o">::</span><span class="n">indices_</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;L(&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;)&quot;</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// Convenience factory function to create expressions made of one</span>
<span class="c1">// monomial L_n.</span>
<span class="n">expression</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">L</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">ret_t</span> <span class="o">=</span> <span class="n">expression</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">return</span> <span class="nf">ret_t</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">ret_t</span><span class="o">::</span><span class="n">monomial_t</span><span class="p">(</span><span class="n">generator_virasoro</span><span class="p">(</span><span class="n">n</span><span class="p">)));</span>
<span class="p">}</span>

<span class="p">}</span> <span class="c1">// namespace libcommute</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">libcommute</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

  <span class="c1">// Check that L(0) is Hermitian and (L_n)^\dagger = L_{-n}</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;conj(L(0)) = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">conj</span><span class="p">(</span><span class="n">L</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;conj(L(1)) = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">conj</span><span class="p">(</span><span class="n">L</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="c1">// Check that L(n)^2 = 0 for a few n</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;L(0) * L(0) = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">L</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">L</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;L(1) * L(1) = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">L</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">L</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;L(-1) * L(-1) = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">L</span><span class="p">(</span><span class="mi">-1</span><span class="p">)</span> <span class="o">*</span> <span class="n">L</span><span class="p">(</span><span class="mi">-1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="c1">// Check recurrence relations from Eq. (5)</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;L_1 - (1/5)[L_3, L_{-2}] = &quot;</span> <span class="o">&lt;&lt;</span>
    <span class="p">(</span><span class="n">L</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">L</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">L</span><span class="p">(</span><span class="mi">-2</span><span class="p">)</span> <span class="o">-</span> <span class="n">L</span><span class="p">(</span><span class="mi">-2</span><span class="p">)</span> <span class="o">*</span> <span class="n">L</span><span class="p">(</span><span class="mi">3</span><span class="p">)))</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;L_{-1} - (1/3)[L_1, L_{-2}] = &quot;</span> <span class="o">&lt;&lt;</span>
    <span class="p">(</span><span class="n">L</span><span class="p">(</span><span class="mi">-1</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">L</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">L</span><span class="p">(</span><span class="mi">-2</span><span class="p">)</span> <span class="o">-</span> <span class="n">L</span><span class="p">(</span><span class="mi">-2</span><span class="p">)</span> <span class="o">*</span> <span class="n">L</span><span class="p">(</span><span class="mi">1</span><span class="p">)))</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;L_2 - (1/4)[L_3, L_{-1}] = &quot;</span> <span class="o">&lt;&lt;</span>
    <span class="p">(</span><span class="n">L</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">L</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">L</span><span class="p">(</span><span class="mi">-1</span><span class="p">)</span> <span class="o">-</span> <span class="n">L</span><span class="p">(</span><span class="mi">-1</span><span class="p">)</span> <span class="o">*</span> <span class="n">L</span><span class="p">(</span><span class="mi">3</span><span class="p">)))</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;L_0 - (1/2)[L_1, L_{-1}] = &quot;</span> <span class="o">&lt;&lt;</span>
    <span class="p">(</span><span class="n">L</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">L</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">L</span><span class="p">(</span><span class="mi">-1</span><span class="p">)</span> <span class="o">-</span> <span class="n">L</span><span class="p">(</span><span class="mi">-1</span><span class="p">)</span> <span class="o">*</span> <span class="n">L</span><span class="p">(</span><span class="mi">1</span><span class="p">)))</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="c1">// Check recurrence relation Eq. (6) for some higher positive n</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;L_&quot;</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; - (1/&quot;</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">n</span><span class="mi">-1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;)&quot;</span>
              <span class="o">&lt;&lt;</span> <span class="s">&quot;[L_&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, L_1] = &quot;</span>
              <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">L</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="n">n</span><span class="mi">-1</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="n">L</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">L</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">L</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">L</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span>
              <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// Check recurrence relation Eq. (7) for some higher negative n</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;L_&quot;</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="o">-</span><span class="n">n</span><span class="mi">-1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; - (1/(&quot;</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">n</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;))&quot;</span>
              <span class="o">&lt;&lt;</span> <span class="s">&quot;[L_&quot;</span> <span class="o">&lt;&lt;</span> <span class="o">-</span><span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, L_{-1}] = &quot;</span>
              <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">L</span><span class="p">(</span><span class="o">-</span><span class="n">n</span><span class="mi">-1</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">n</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="n">L</span><span class="p">(</span><span class="o">-</span><span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">L</span><span class="p">(</span><span class="mi">-1</span><span class="p">)</span> <span class="o">-</span> <span class="n">L</span><span class="p">(</span><span class="mi">-1</span><span class="p">)</span> <span class="o">*</span> <span class="n">L</span><span class="p">(</span><span class="o">-</span><span class="n">n</span><span class="p">)))</span>
              <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<dl class="citation">
<dt class="label" id="fnz88"><span class="brackets"><a class="fn-backref" href="#id2">FNZ88</a></span></dt>
<dd><p>“A presentation for the Virasoro and super-Virasoro algebras”,
D. B. Fairlie, J. Nuyts and C. K. Zachos ,
Commun. Math. Phys. <strong>117</strong>, pp. 595–614 (1988),
<a class="reference external" href="https://doi.org/10.1007/BF01218387">https://doi.org/10.1007/BF01218387</a></p>
</dd>
</dl>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../genindex.html" class="btn btn-neutral float-right" title="Index" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="parametric_loperator.html" class="btn btn-neutral float-left" title="Custom scalar types and parametric_loperator" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2016-2020, Igor Krivenko

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>