/*******************************************************************************
 *
 * This file is part of libcommute, a C++11/14/17 header-only library allowing
 * to manipulate polynomial expressions with quantum-mechanical operators.
 *
 * Copyright (C) 2016-2019 Igor Krivenko <igor.s.krivenko@gmail.com>
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 *
 ******************************************************************************/
#ifndef LIBCOMMUTE_BASIS_SPACE_SPIN_HPP_
#define LIBCOMMUTE_BASIS_SPACE_SPIN_HPP_

#include "../algebra_tags.hpp"
#include "../metafunctions.hpp"
#include "../utility.hpp"

#include "basis_space.hpp"

#include <cmath>

namespace libcommute {

//
// Basis space generated by one spin degree of freedom
//

template<typename... IndexTypes>
class basis_space_spin : public basis_space<IndexTypes...> {

  using base = basis_space<IndexTypes...>;

public:

  // Value symantics
  basis_space_spin() = delete;
  template<typename... Args>
  basis_space_spin(double spin, Args&&... indices)
    : base(std::forward<Args>(indices)...), multiplicity_(2*spin+1) {
    // Multiplicity has to be integer
    assert(2*spin == int(spin*2));
    n_bits_ = std::ceil(std::log2(multiplicity_));
  }
  basis_space_spin(basis_space_spin const&) = default;
  basis_space_spin(basis_space_spin&&) noexcept = default;
  basis_space_spin& operator=(basis_space_spin const&) = default;
  basis_space_spin& operator=(basis_space_spin&&) noexcept = default;

  // Make a smart pointer that manages a copy of this basis space
  virtual std::unique_ptr<base> clone() const override {
#ifndef LIBCOMMUTE_NO_STD_MAKE_UNIQUE
    using std::make_unique;
#endif
    return make_unique<basis_space_spin>(*this);
  }

  // ID of the algebra this basis space is associated with
  virtual int algebra_id() const override { return spin::algebra_id(); }

  // The minimal number of binary digits needed to represent any state
  // in this basis space
  virtual int n_bits() const override { return n_bits_; }

protected:

  // Multiplicity, 2S+1
  int multiplicity_;

  // n_bits_ is the smallest positive number such that 2^{n_bits_} - 1
  // exceed multiplicity of the respective spin algebra.
  int n_bits_;

  // Equality
  virtual bool equal(base const& bs) const override {
    auto const& bs_s = dynamic_cast<basis_space_spin const&>(bs);
    return this->multiplicity_ == bs_s.multiplicity_ && base::equal(bs);
  }

  // Ordering
  virtual bool less(base const& bs) const override {
    auto const& bs_s =  dynamic_cast<basis_space_spin const&>(bs);
    if(this->multiplicity_ != bs_s.multiplicity_)
      return this->multiplicity_ < bs_s.multiplicity_;
    else
      return base::less(bs);
  }
  virtual bool greater(base const& bs) const override {
    auto const& bs_s =  dynamic_cast<basis_space_spin const&>(bs);
    if(this->multiplicity_ != bs_s.multiplicity_)
      return this->multiplicity_ > bs_s.multiplicity_;
    else
      return base::greater(bs);
  }
};

namespace static_indices {

// Convenience factory function
template<typename... IndexTypes>
inline basis_space_spin<c_str_to_string_t<IndexTypes>...>
make_space_spin(double spin, IndexTypes&&... indices) {
  return {spin, std::forward<IndexTypes>(indices)...};
}

} // namespace libcommute::static_indices
} // namespace libcommute

#if __cplusplus >= 201703L
#include "../expression/dyn_indices.hpp"

namespace libcommute {
namespace dynamic_indices {

// Convenience factory function for dynamic indices
template<typename... IndexTypes>
inline basis_space_spin<dyn_indices>
make_space_spin(double spin, IndexTypes&&... indices) {
  return {spin, dyn_indices(std::forward<IndexTypes>(indices)...)};
}

} // namespace libcommute::dynamic_indices
} // namespace libcommute
#endif

#endif
